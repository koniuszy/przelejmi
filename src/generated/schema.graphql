### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Client {
  Scenario(cursor: ScenarioWhereUniqueInput, skip: Int, take: Int): [Scenario!]!
  VATId: String
  address: String!
  city: String!
  country: String!
  id: Int!
  name: String!
  postCode: String!
}

input ClientCreateInput {
  Scenario: ScenarioCreateNestedManyWithoutClientInput
  VATId: String
  address: String!
  city: String!
  country: String!
  name: String!
  postCode: String!
}

input ClientCreateNestedOneWithoutScenarioInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithoutScenarioInput
  create: ClientCreateWithoutScenarioInput
}

input ClientCreateOrConnectWithoutScenarioInput {
  create: ClientCreateWithoutScenarioInput!
  where: ClientWhereUniqueInput!
}

input ClientCreateWithoutScenarioInput {
  VATId: String
  address: String!
  city: String!
  country: String!
  name: String!
  postCode: String!
}

type ClientList {
  list: [Client]
  totalCount: Int
}

input ClientOrderByInput {
  VATId: SortOrder
  address: SortOrder
  city: SortOrder
  country: SortOrder
  id: SortOrder
  name: SortOrder
  postCode: SortOrder
}

input ClientUpdateInput {
  Scenario: ScenarioUpdateManyWithoutClientInput
  VATId: String
  address: String
  city: String
  country: String
  name: String
  postCode: String
}

input ClientUpdateOneRequiredWithoutScenarioInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithoutScenarioInput
  create: ClientCreateWithoutScenarioInput
  update: ClientUpdateWithoutScenarioInput
  upsert: ClientUpsertWithoutScenarioInput
}

input ClientUpdateWithoutScenarioInput {
  VATId: String
  address: String
  city: String
  country: String
  name: String
  postCode: String
}

input ClientUpsertWithoutScenarioInput {
  create: ClientCreateWithoutScenarioInput!
  update: ClientUpdateWithoutScenarioInput!
}

input ClientWhereInput {
  AND: [ClientWhereInput!]
  NOT: [ClientWhereInput!]
  OR: [ClientWhereInput!]
  Scenario: ScenarioListRelationFilter
  VATId: StringNullableFilter
  address: StringFilter
  city: StringFilter
  country: StringFilter
  id: IntFilter
  name: StringFilter
  postCode: StringFilter
}

input ClientWhereUniqueInput {
  id: Int
}

enum Currency {
  EUR
  NOK
  PLN
  USD
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input EnumCurrencyFilter {
  equals: Currency
  in: [Currency!]
  not: NestedEnumCurrencyFilter
  notIn: [Currency!]
}

input EnumPaymentTypeFilter {
  equals: PaymentType
  in: [PaymentType!]
  not: NestedEnumPaymentTypeFilter
  notIn: [PaymentType!]
}

input EnumUnitFilter {
  equals: Unit
  in: [Unit!]
  not: NestedEnumUnitFilter
  notIn: [Unit!]
}

input EnumVATFilter {
  equals: VAT
  in: [VAT!]
  not: NestedEnumVATFilter
  notIn: [VAT!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type Merchant {
  Scenario(cursor: ScenarioWhereUniqueInput, skip: Int, take: Int): [Scenario!]!
  VATId: String!
  address: String!
  bankAccountEur: String
  bankAccountPln: String!
  bankName: String!
  city: String!
  companyName: String!
  country: String!
  email: String!
  id: Int!
  issuerName: String!
  postCode: String!
}

input MerchantCreateInput {
  Scenario: ScenarioCreateNestedManyWithoutMerchantInput
  VATId: String!
  address: String!
  bankAccountEur: String
  bankAccountPln: String!
  bankName: String!
  city: String!
  companyName: String!
  country: String!
  email: String!
  issuerName: String!
  postCode: String!
}

input MerchantCreateNestedOneWithoutScenarioInput {
  connect: MerchantWhereUniqueInput
  connectOrCreate: MerchantCreateOrConnectWithoutScenarioInput
  create: MerchantCreateWithoutScenarioInput
}

input MerchantCreateOrConnectWithoutScenarioInput {
  create: MerchantCreateWithoutScenarioInput!
  where: MerchantWhereUniqueInput!
}

input MerchantCreateWithoutScenarioInput {
  VATId: String!
  address: String!
  bankAccountEur: String
  bankAccountPln: String!
  bankName: String!
  city: String!
  companyName: String!
  country: String!
  email: String!
  issuerName: String!
  postCode: String!
}

type MerchantList {
  list: [Merchant]
  totalCount: Int
}

input MerchantOrderByInput {
  VATId: SortOrder
  address: SortOrder
  bankAccountEur: SortOrder
  bankAccountPln: SortOrder
  bankName: SortOrder
  city: SortOrder
  companyName: SortOrder
  country: SortOrder
  email: SortOrder
  id: SortOrder
  issuerName: SortOrder
  postCode: SortOrder
}

input MerchantUpdateInput {
  Scenario: ScenarioUpdateManyWithoutMerchantInput
  VATId: String
  address: String
  bankAccountEur: String
  bankAccountPln: String
  bankName: String
  city: String
  companyName: String
  country: String
  email: String
  issuerName: String
  postCode: String
}

input MerchantUpdateOneRequiredWithoutScenarioInput {
  connect: MerchantWhereUniqueInput
  connectOrCreate: MerchantCreateOrConnectWithoutScenarioInput
  create: MerchantCreateWithoutScenarioInput
  update: MerchantUpdateWithoutScenarioInput
  upsert: MerchantUpsertWithoutScenarioInput
}

input MerchantUpdateWithoutScenarioInput {
  VATId: String
  address: String
  bankAccountEur: String
  bankAccountPln: String
  bankName: String
  city: String
  companyName: String
  country: String
  email: String
  issuerName: String
  postCode: String
}

input MerchantUpsertWithoutScenarioInput {
  create: MerchantCreateWithoutScenarioInput!
  update: MerchantUpdateWithoutScenarioInput!
}

input MerchantWhereInput {
  AND: [MerchantWhereInput!]
  NOT: [MerchantWhereInput!]
  OR: [MerchantWhereInput!]
  Scenario: ScenarioListRelationFilter
  VATId: StringFilter
  address: StringFilter
  bankAccountEur: StringNullableFilter
  bankAccountPln: StringFilter
  bankName: StringFilter
  city: StringFilter
  companyName: StringFilter
  country: StringFilter
  email: StringFilter
  id: IntFilter
  issuerName: StringFilter
  postCode: StringFilter
}

input MerchantWhereUniqueInput {
  id: Int
}

type Mutation {
  createOneClient(data: ClientCreateInput!): Client!
  createOneMerchant(data: MerchantCreateInput!): Merchant!
  createOneScenario(data: ScenarioCreateInput!): Scenario!
  deleteOneClient(where: ClientWhereUniqueInput!): Client
  deleteOneMerchant(where: MerchantWhereUniqueInput!): Merchant
  updateOneClient(data: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client
  updateOneMerchant(data: MerchantUpdateInput!, where: MerchantWhereUniqueInput!): Merchant
  updateOneScenario(data: ScenarioUpdateInput!, where: ScenarioWhereUniqueInput!): Scenario
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedEnumCurrencyFilter {
  equals: Currency
  in: [Currency!]
  not: NestedEnumCurrencyFilter
  notIn: [Currency!]
}

input NestedEnumPaymentTypeFilter {
  equals: PaymentType
  in: [PaymentType!]
  not: NestedEnumPaymentTypeFilter
  notIn: [PaymentType!]
}

input NestedEnumUnitFilter {
  equals: Unit
  in: [Unit!]
  not: NestedEnumUnitFilter
  notIn: [Unit!]
}

input NestedEnumVATFilter {
  equals: VAT
  in: [VAT!]
  not: NestedEnumVATFilter
  notIn: [VAT!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type PaginatedClientList {
  filters: PaginatedClientListFilters
  list: [Client]
  totalCount: Int
}

type PaginatedClientListFilters {
  city: [String]
  country: [String]
}

type PaginatedMerchantList {
  filters: PaginatedMerchantListFilters
  list: [Merchant]
  totalCount: Int
}

type PaginatedMerchantListFilters {
  bank: [String]
  city: [String]
  country: [String]
}

enum PaymentType {
  CASH
  TRANSFER
}

type Query {
  client(where: ClientWhereUniqueInput!): Client
  clientList: ClientList
  clients(cursor: ClientWhereUniqueInput, orderBy: [ClientOrderByInput!], skip: Int, take: Int, where: ClientWhereInput): [Client!]!
  merchant(where: MerchantWhereUniqueInput!): Merchant
  merchantList: MerchantList
  merchants(cursor: MerchantWhereUniqueInput, orderBy: [MerchantOrderByInput!], skip: Int, take: Int, where: MerchantWhereInput): [Merchant!]!
  paginatedClientList(orderBy: [ClientOrderByInput], skip: Int!, take: Int!, where: ClientWhereInput): PaginatedClientList
  paginatedMerchantList(orderBy: [MerchantOrderByInput], skip: Int!, take: Int!, where: MerchantWhereInput): PaginatedMerchantList
  scenario(where: ScenarioWhereUniqueInput!): Scenario
  scenarios(cursor: ScenarioWhereUniqueInput, skip: Int, take: Int): [Scenario!]!
}

enum QueryMode {
  default
  insensitive
}

type Scenario {
  VAT: VAT!
  client: Client!
  clientId: Int!
  createdAt: DateTime!
  currency: Currency!
  dueDateDays: Int!
  id: Int!
  imgUrl: String!
  merchant: Merchant!
  merchantId: Int!
  name: String!
  netPerOne: Int!
  notes: String!
  paymentType: PaymentType!
  unitType: Unit!
  updatedAt: DateTime!
}

input ScenarioCreateInput {
  VAT: VAT!
  client: ClientCreateNestedOneWithoutScenarioInput!
  createdAt: DateTime
  currency: Currency!
  dueDateDays: Int!
  imgUrl: String!
  merchant: MerchantCreateNestedOneWithoutScenarioInput!
  name: String!
  netPerOne: Int!
  notes: String!
  paymentType: PaymentType!
  unitType: Unit!
  updatedAt: DateTime
}

input ScenarioCreateManyClientInput {
  VAT: VAT!
  createdAt: DateTime
  currency: Currency!
  dueDateDays: Int!
  id: Int
  imgUrl: String!
  merchantId: Int!
  name: String!
  netPerOne: Int!
  notes: String!
  paymentType: PaymentType!
  unitType: Unit!
  updatedAt: DateTime
}

input ScenarioCreateManyClientInputEnvelope {
  data: [ScenarioCreateManyClientInput!]
  skipDuplicates: Boolean
}

input ScenarioCreateManyMerchantInput {
  VAT: VAT!
  clientId: Int!
  createdAt: DateTime
  currency: Currency!
  dueDateDays: Int!
  id: Int
  imgUrl: String!
  name: String!
  netPerOne: Int!
  notes: String!
  paymentType: PaymentType!
  unitType: Unit!
  updatedAt: DateTime
}

input ScenarioCreateManyMerchantInputEnvelope {
  data: [ScenarioCreateManyMerchantInput!]
  skipDuplicates: Boolean
}

input ScenarioCreateNestedManyWithoutClientInput {
  connect: [ScenarioWhereUniqueInput!]
  connectOrCreate: [ScenarioCreateOrConnectWithoutClientInput!]
  create: [ScenarioCreateWithoutClientInput!]
  createMany: ScenarioCreateManyClientInputEnvelope
}

input ScenarioCreateNestedManyWithoutMerchantInput {
  connect: [ScenarioWhereUniqueInput!]
  connectOrCreate: [ScenarioCreateOrConnectWithoutMerchantInput!]
  create: [ScenarioCreateWithoutMerchantInput!]
  createMany: ScenarioCreateManyMerchantInputEnvelope
}

input ScenarioCreateOrConnectWithoutClientInput {
  create: ScenarioCreateWithoutClientInput!
  where: ScenarioWhereUniqueInput!
}

input ScenarioCreateOrConnectWithoutMerchantInput {
  create: ScenarioCreateWithoutMerchantInput!
  where: ScenarioWhereUniqueInput!
}

input ScenarioCreateWithoutClientInput {
  VAT: VAT!
  createdAt: DateTime
  currency: Currency!
  dueDateDays: Int!
  imgUrl: String!
  merchant: MerchantCreateNestedOneWithoutScenarioInput!
  name: String!
  netPerOne: Int!
  notes: String!
  paymentType: PaymentType!
  unitType: Unit!
  updatedAt: DateTime
}

input ScenarioCreateWithoutMerchantInput {
  VAT: VAT!
  client: ClientCreateNestedOneWithoutScenarioInput!
  createdAt: DateTime
  currency: Currency!
  dueDateDays: Int!
  imgUrl: String!
  name: String!
  netPerOne: Int!
  notes: String!
  paymentType: PaymentType!
  unitType: Unit!
  updatedAt: DateTime
}

input ScenarioListRelationFilter {
  every: ScenarioWhereInput
  none: ScenarioWhereInput
  some: ScenarioWhereInput
}

input ScenarioScalarWhereInput {
  AND: [ScenarioScalarWhereInput!]
  NOT: [ScenarioScalarWhereInput!]
  OR: [ScenarioScalarWhereInput!]
  VAT: EnumVATFilter
  clientId: IntFilter
  createdAt: DateTimeFilter
  currency: EnumCurrencyFilter
  dueDateDays: IntFilter
  id: IntFilter
  imgUrl: StringFilter
  merchantId: IntFilter
  name: StringFilter
  netPerOne: IntFilter
  notes: StringFilter
  paymentType: EnumPaymentTypeFilter
  unitType: EnumUnitFilter
  updatedAt: DateTimeFilter
}

input ScenarioUpdateInput {
  VAT: VAT
  client: ClientUpdateOneRequiredWithoutScenarioInput
  createdAt: DateTime
  currency: Currency
  dueDateDays: Int
  imgUrl: String
  merchant: MerchantUpdateOneRequiredWithoutScenarioInput
  name: String
  netPerOne: Int
  notes: String
  paymentType: PaymentType
  unitType: Unit
  updatedAt: DateTime
}

input ScenarioUpdateManyMutationInput {
  VAT: VAT
  createdAt: DateTime
  currency: Currency
  dueDateDays: Int
  imgUrl: String
  name: String
  netPerOne: Int
  notes: String
  paymentType: PaymentType
  unitType: Unit
  updatedAt: DateTime
}

input ScenarioUpdateManyWithWhereWithoutClientInput {
  data: ScenarioUpdateManyMutationInput!
  where: ScenarioScalarWhereInput!
}

input ScenarioUpdateManyWithWhereWithoutMerchantInput {
  data: ScenarioUpdateManyMutationInput!
  where: ScenarioScalarWhereInput!
}

input ScenarioUpdateManyWithoutClientInput {
  connect: [ScenarioWhereUniqueInput!]
  connectOrCreate: [ScenarioCreateOrConnectWithoutClientInput!]
  create: [ScenarioCreateWithoutClientInput!]
  createMany: ScenarioCreateManyClientInputEnvelope
  delete: [ScenarioWhereUniqueInput!]
  deleteMany: [ScenarioScalarWhereInput!]
  disconnect: [ScenarioWhereUniqueInput!]
  set: [ScenarioWhereUniqueInput!]
  update: [ScenarioUpdateWithWhereUniqueWithoutClientInput!]
  updateMany: [ScenarioUpdateManyWithWhereWithoutClientInput!]
  upsert: [ScenarioUpsertWithWhereUniqueWithoutClientInput!]
}

input ScenarioUpdateManyWithoutMerchantInput {
  connect: [ScenarioWhereUniqueInput!]
  connectOrCreate: [ScenarioCreateOrConnectWithoutMerchantInput!]
  create: [ScenarioCreateWithoutMerchantInput!]
  createMany: ScenarioCreateManyMerchantInputEnvelope
  delete: [ScenarioWhereUniqueInput!]
  deleteMany: [ScenarioScalarWhereInput!]
  disconnect: [ScenarioWhereUniqueInput!]
  set: [ScenarioWhereUniqueInput!]
  update: [ScenarioUpdateWithWhereUniqueWithoutMerchantInput!]
  updateMany: [ScenarioUpdateManyWithWhereWithoutMerchantInput!]
  upsert: [ScenarioUpsertWithWhereUniqueWithoutMerchantInput!]
}

input ScenarioUpdateWithWhereUniqueWithoutClientInput {
  data: ScenarioUpdateWithoutClientInput!
  where: ScenarioWhereUniqueInput!
}

input ScenarioUpdateWithWhereUniqueWithoutMerchantInput {
  data: ScenarioUpdateWithoutMerchantInput!
  where: ScenarioWhereUniqueInput!
}

input ScenarioUpdateWithoutClientInput {
  VAT: VAT
  createdAt: DateTime
  currency: Currency
  dueDateDays: Int
  imgUrl: String
  merchant: MerchantUpdateOneRequiredWithoutScenarioInput
  name: String
  netPerOne: Int
  notes: String
  paymentType: PaymentType
  unitType: Unit
  updatedAt: DateTime
}

input ScenarioUpdateWithoutMerchantInput {
  VAT: VAT
  client: ClientUpdateOneRequiredWithoutScenarioInput
  createdAt: DateTime
  currency: Currency
  dueDateDays: Int
  imgUrl: String
  name: String
  netPerOne: Int
  notes: String
  paymentType: PaymentType
  unitType: Unit
  updatedAt: DateTime
}

input ScenarioUpsertWithWhereUniqueWithoutClientInput {
  create: ScenarioCreateWithoutClientInput!
  update: ScenarioUpdateWithoutClientInput!
  where: ScenarioWhereUniqueInput!
}

input ScenarioUpsertWithWhereUniqueWithoutMerchantInput {
  create: ScenarioCreateWithoutMerchantInput!
  update: ScenarioUpdateWithoutMerchantInput!
  where: ScenarioWhereUniqueInput!
}

input ScenarioWhereInput {
  AND: [ScenarioWhereInput!]
  NOT: [ScenarioWhereInput!]
  OR: [ScenarioWhereInput!]
  VAT: EnumVATFilter
  client: ClientWhereInput
  clientId: IntFilter
  createdAt: DateTimeFilter
  currency: EnumCurrencyFilter
  dueDateDays: IntFilter
  id: IntFilter
  imgUrl: StringFilter
  merchant: MerchantWhereInput
  merchantId: IntFilter
  name: StringFilter
  netPerOne: IntFilter
  notes: StringFilter
  paymentType: EnumPaymentTypeFilter
  unitType: EnumUnitFilter
  updatedAt: DateTimeFilter
}

input ScenarioWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

enum Unit {
  HOUR
  ITEM
}

enum VAT {
  DOES_NOT_CONCERN
  FREED
  PERCENT_0
  PERCENT_8
  PERCENT_23
}
