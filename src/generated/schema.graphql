### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Client {
  Scenario(cursor: ScenarioWhereUniqueInput, skip: Int, take: Int): [Scenario!]!
  address: String!
  city: String!
  country: String!
  id: Int!
  name: String!
  postCode: String!
}

input ClientCreateInput {
  Scenario: ScenarioCreateNestedManyWithoutClientInput
  VAT: String
  address: String!
  city: String!
  country: String!
  name: String!
  postCode: String!
}

input ClientCreateNestedOneWithoutScenarioInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithoutScenarioInput
  create: ClientCreateWithoutScenarioInput
}

input ClientCreateOrConnectWithoutScenarioInput {
  create: ClientCreateWithoutScenarioInput!
  where: ClientWhereUniqueInput!
}

input ClientCreateWithoutScenarioInput {
  VAT: String
  address: String!
  city: String!
  country: String!
  name: String!
  postCode: String!
}

input ClientOrderByInput {
  VAT: SortOrder
  address: SortOrder
  city: SortOrder
  country: SortOrder
  id: SortOrder
  name: SortOrder
  postCode: SortOrder
}

input ClientUpdateInput {
  Scenario: ScenarioUpdateManyWithoutClientInput
  VAT: String
  address: String
  city: String
  country: String
  name: String
  postCode: String
}

input ClientUpdateOneRequiredWithoutScenarioInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithoutScenarioInput
  create: ClientCreateWithoutScenarioInput
  update: ClientUpdateWithoutScenarioInput
  upsert: ClientUpsertWithoutScenarioInput
}

input ClientUpdateWithoutScenarioInput {
  VAT: String
  address: String
  city: String
  country: String
  name: String
  postCode: String
}

input ClientUpsertWithoutScenarioInput {
  create: ClientCreateWithoutScenarioInput!
  update: ClientUpdateWithoutScenarioInput!
}

input ClientWhereInput {
  AND: [ClientWhereInput!]
  NOT: [ClientWhereInput!]
  OR: [ClientWhereInput!]
  Scenario: ScenarioListRelationFilter
  VAT: StringNullableFilter
  address: StringFilter
  city: StringFilter
  country: StringFilter
  id: IntFilter
  name: StringFilter
  postCode: StringFilter
}

input ClientWhereUniqueInput {
  id: Int
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type Merchant {
  Scenario(cursor: ScenarioWhereUniqueInput, skip: Int, take: Int): [Scenario!]!
  address: String!
  bankAccountEur: String
  bankAccountPln: String!
  bankName: String!
  city: String!
  companyName: String!
  country: String!
  email: String!
  id: Int!
  issuerName: String!
  postCode: String!
}

input MerchantCreateInput {
  Scenario: ScenarioCreateNestedManyWithoutMerchantInput
  VAT: String!
  address: String!
  bankAccountEur: String
  bankAccountPln: String!
  bankName: String!
  city: String!
  companyName: String!
  country: String!
  email: String!
  issuerName: String!
  postCode: String!
}

input MerchantCreateNestedOneWithoutScenarioInput {
  connect: MerchantWhereUniqueInput
  connectOrCreate: MerchantCreateOrConnectWithoutScenarioInput
  create: MerchantCreateWithoutScenarioInput
}

input MerchantCreateOrConnectWithoutScenarioInput {
  create: MerchantCreateWithoutScenarioInput!
  where: MerchantWhereUniqueInput!
}

input MerchantCreateWithoutScenarioInput {
  VAT: String!
  address: String!
  bankAccountEur: String
  bankAccountPln: String!
  bankName: String!
  city: String!
  companyName: String!
  country: String!
  email: String!
  issuerName: String!
  postCode: String!
}

input MerchantOrderByInput {
  VAT: SortOrder
  address: SortOrder
  bankAccountEur: SortOrder
  bankAccountPln: SortOrder
  bankName: SortOrder
  city: SortOrder
  companyName: SortOrder
  country: SortOrder
  email: SortOrder
  id: SortOrder
  issuerName: SortOrder
  postCode: SortOrder
}

input MerchantUpdateInput {
  Scenario: ScenarioUpdateManyWithoutMerchantInput
  VAT: String
  address: String
  bankAccountEur: String
  bankAccountPln: String
  bankName: String
  city: String
  companyName: String
  country: String
  email: String
  issuerName: String
  postCode: String
}

input MerchantUpdateOneRequiredWithoutScenarioInput {
  connect: MerchantWhereUniqueInput
  connectOrCreate: MerchantCreateOrConnectWithoutScenarioInput
  create: MerchantCreateWithoutScenarioInput
  update: MerchantUpdateWithoutScenarioInput
  upsert: MerchantUpsertWithoutScenarioInput
}

input MerchantUpdateWithoutScenarioInput {
  VAT: String
  address: String
  bankAccountEur: String
  bankAccountPln: String
  bankName: String
  city: String
  companyName: String
  country: String
  email: String
  issuerName: String
  postCode: String
}

input MerchantUpsertWithoutScenarioInput {
  create: MerchantCreateWithoutScenarioInput!
  update: MerchantUpdateWithoutScenarioInput!
}

input MerchantWhereInput {
  AND: [MerchantWhereInput!]
  NOT: [MerchantWhereInput!]
  OR: [MerchantWhereInput!]
  Scenario: ScenarioListRelationFilter
  VAT: StringFilter
  address: StringFilter
  bankAccountEur: StringNullableFilter
  bankAccountPln: StringFilter
  bankName: StringFilter
  city: StringFilter
  companyName: StringFilter
  country: StringFilter
  email: StringFilter
  id: IntFilter
  issuerName: StringFilter
  postCode: StringFilter
}

input MerchantWhereUniqueInput {
  id: Int
}

type Mutation {
  createOneClient(data: ClientCreateInput!): Client!
  createOneMerchant(data: MerchantCreateInput!): Merchant!
  createOneScenario(data: ScenarioCreateInput!): Scenario!
  deleteOneClient(where: ClientWhereUniqueInput!): Client
  deleteOneMerchant(where: MerchantWhereUniqueInput!): Merchant
  updateOneClient(data: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client
  updateOneMerchant(data: MerchantUpdateInput!, where: MerchantWhereUniqueInput!): Merchant
  updateOneScenario(data: ScenarioUpdateInput!, where: ScenarioWhereUniqueInput!): Scenario
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type PaginatedClients {
  list: [Client]
  totalCount: Int
}

type PaginatedMerchants {
  list: [Merchant]
  totalCount: Int
}

type Query {
  client(where: ClientWhereUniqueInput!): Client
  clients(cursor: ClientWhereUniqueInput, orderBy: [ClientOrderByInput!], skip: Int, take: Int, where: ClientWhereInput): [Client!]!
  merchant(where: MerchantWhereUniqueInput!): Merchant
  merchants(cursor: MerchantWhereUniqueInput, orderBy: [MerchantOrderByInput!], skip: Int, take: Int, where: MerchantWhereInput): [Merchant!]!
  paginatedClients(orderBy: [ClientOrderByInput], skip: Int!, take: Int!, where: ClientWhereInput): PaginatedClients
  paginatedMerchants(orderBy: [MerchantOrderByInput], skip: Int!, take: Int!, where: MerchantWhereInput): PaginatedMerchants
  scenario(where: ScenarioWhereUniqueInput!): Scenario
  scenarios(cursor: ScenarioWhereUniqueInput, skip: Int, take: Int): [Scenario!]!
}

enum QueryMode {
  default
  insensitive
}

type Scenario {
  VAT: Int!
  amount: Int!
  client: Client!
  clientId: Int!
  createdAt: DateTime!
  id: Int!
  merchant: Merchant!
  merchantId: Int!
  name: String!
  netPerOne: Int!
  notes: String!
  paymentType: String!
  unit: String!
  updatedAt: DateTime!
}

input ScenarioCreateInput {
  VAT: Int!
  amount: Int!
  client: ClientCreateNestedOneWithoutScenarioInput!
  createdAt: DateTime
  dayPayments: Int!
  merchant: MerchantCreateNestedOneWithoutScenarioInput!
  name: String!
  netPerOne: Int!
  notes: String!
  paymentType: String!
  unit: String!
  updatedAt: DateTime
}

input ScenarioCreateNestedManyWithoutClientInput {
  connect: [ScenarioWhereUniqueInput!]
  connectOrCreate: [ScenarioCreateOrConnectWithoutclientInput!]
  create: [ScenarioCreateWithoutClientInput!]
}

input ScenarioCreateNestedManyWithoutMerchantInput {
  connect: [ScenarioWhereUniqueInput!]
  connectOrCreate: [ScenarioCreateOrConnectWithoutmerchantInput!]
  create: [ScenarioCreateWithoutMerchantInput!]
}

input ScenarioCreateOrConnectWithoutclientInput {
  create: ScenarioCreateWithoutClientInput!
  where: ScenarioWhereUniqueInput!
}

input ScenarioCreateOrConnectWithoutmerchantInput {
  create: ScenarioCreateWithoutMerchantInput!
  where: ScenarioWhereUniqueInput!
}

input ScenarioCreateWithoutClientInput {
  VAT: Int!
  amount: Int!
  createdAt: DateTime
  dayPayments: Int!
  merchant: MerchantCreateNestedOneWithoutScenarioInput!
  name: String!
  netPerOne: Int!
  notes: String!
  paymentType: String!
  unit: String!
  updatedAt: DateTime
}

input ScenarioCreateWithoutMerchantInput {
  VAT: Int!
  amount: Int!
  client: ClientCreateNestedOneWithoutScenarioInput!
  createdAt: DateTime
  dayPayments: Int!
  name: String!
  netPerOne: Int!
  notes: String!
  paymentType: String!
  unit: String!
  updatedAt: DateTime
}

input ScenarioListRelationFilter {
  every: ScenarioWhereInput
  none: ScenarioWhereInput
  some: ScenarioWhereInput
}

input ScenarioScalarWhereInput {
  AND: [ScenarioScalarWhereInput!]
  NOT: [ScenarioScalarWhereInput!]
  OR: [ScenarioScalarWhereInput!]
  VAT: IntFilter
  amount: IntFilter
  clientId: IntFilter
  createdAt: DateTimeFilter
  dayPayments: IntFilter
  id: IntFilter
  merchantId: IntFilter
  name: StringFilter
  netPerOne: IntFilter
  notes: StringFilter
  paymentType: StringFilter
  unit: StringFilter
  updatedAt: DateTimeFilter
}

input ScenarioUpdateInput {
  VAT: Int
  amount: Int
  client: ClientUpdateOneRequiredWithoutScenarioInput
  createdAt: DateTime
  dayPayments: Int
  merchant: MerchantUpdateOneRequiredWithoutScenarioInput
  name: String
  netPerOne: Int
  notes: String
  paymentType: String
  unit: String
  updatedAt: DateTime
}

input ScenarioUpdateManyMutationInput {
  VAT: Int
  amount: Int
  createdAt: DateTime
  dayPayments: Int
  name: String
  netPerOne: Int
  notes: String
  paymentType: String
  unit: String
  updatedAt: DateTime
}

input ScenarioUpdateManyWithWhereWithoutClientInput {
  data: ScenarioUpdateManyMutationInput!
  where: ScenarioScalarWhereInput!
}

input ScenarioUpdateManyWithWhereWithoutMerchantInput {
  data: ScenarioUpdateManyMutationInput!
  where: ScenarioScalarWhereInput!
}

input ScenarioUpdateManyWithoutClientInput {
  connect: [ScenarioWhereUniqueInput!]
  connectOrCreate: [ScenarioCreateOrConnectWithoutclientInput!]
  create: [ScenarioCreateWithoutClientInput!]
  delete: [ScenarioWhereUniqueInput!]
  deleteMany: [ScenarioScalarWhereInput!]
  disconnect: [ScenarioWhereUniqueInput!]
  set: [ScenarioWhereUniqueInput!]
  update: [ScenarioUpdateWithWhereUniqueWithoutClientInput!]
  updateMany: [ScenarioUpdateManyWithWhereWithoutClientInput!]
  upsert: [ScenarioUpsertWithWhereUniqueWithoutClientInput!]
}

input ScenarioUpdateManyWithoutMerchantInput {
  connect: [ScenarioWhereUniqueInput!]
  connectOrCreate: [ScenarioCreateOrConnectWithoutmerchantInput!]
  create: [ScenarioCreateWithoutMerchantInput!]
  delete: [ScenarioWhereUniqueInput!]
  deleteMany: [ScenarioScalarWhereInput!]
  disconnect: [ScenarioWhereUniqueInput!]
  set: [ScenarioWhereUniqueInput!]
  update: [ScenarioUpdateWithWhereUniqueWithoutMerchantInput!]
  updateMany: [ScenarioUpdateManyWithWhereWithoutMerchantInput!]
  upsert: [ScenarioUpsertWithWhereUniqueWithoutMerchantInput!]
}

input ScenarioUpdateWithWhereUniqueWithoutClientInput {
  data: ScenarioUpdateWithoutClientInput!
  where: ScenarioWhereUniqueInput!
}

input ScenarioUpdateWithWhereUniqueWithoutMerchantInput {
  data: ScenarioUpdateWithoutMerchantInput!
  where: ScenarioWhereUniqueInput!
}

input ScenarioUpdateWithoutClientInput {
  VAT: Int
  amount: Int
  createdAt: DateTime
  dayPayments: Int
  merchant: MerchantUpdateOneRequiredWithoutScenarioInput
  name: String
  netPerOne: Int
  notes: String
  paymentType: String
  unit: String
  updatedAt: DateTime
}

input ScenarioUpdateWithoutMerchantInput {
  VAT: Int
  amount: Int
  client: ClientUpdateOneRequiredWithoutScenarioInput
  createdAt: DateTime
  dayPayments: Int
  name: String
  netPerOne: Int
  notes: String
  paymentType: String
  unit: String
  updatedAt: DateTime
}

input ScenarioUpsertWithWhereUniqueWithoutClientInput {
  create: ScenarioCreateWithoutClientInput!
  update: ScenarioUpdateWithoutClientInput!
  where: ScenarioWhereUniqueInput!
}

input ScenarioUpsertWithWhereUniqueWithoutMerchantInput {
  create: ScenarioCreateWithoutMerchantInput!
  update: ScenarioUpdateWithoutMerchantInput!
  where: ScenarioWhereUniqueInput!
}

input ScenarioWhereInput {
  AND: [ScenarioWhereInput!]
  NOT: [ScenarioWhereInput!]
  OR: [ScenarioWhereInput!]
  VAT: IntFilter
  amount: IntFilter
  client: ClientWhereInput
  clientId: IntFilter
  createdAt: DateTimeFilter
  dayPayments: IntFilter
  id: IntFilter
  merchant: MerchantWhereInput
  merchantId: IntFilter
  name: StringFilter
  netPerOne: IntFilter
  notes: StringFilter
  paymentType: StringFilter
  unit: StringFilter
  updatedAt: DateTimeFilter
}

input ScenarioWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}
